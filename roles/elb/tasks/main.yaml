---

# get current account id
- name: get user details
  local_action: command aws iam get-user --output json
  register: myuser
- set_fact:
    myuser_out: "{{ myuser.stdout }}"
- debug: msg="Working on account {{ myuser_out.User.Arn[13:25] }} ..."

# try acquiring acm certificate (currently only exist for us-east-1)
- name: list acm certificates for our domain
  shell: aws acm list-certificates --certificate-statuses ISSUED
  ignore_errors: yes
  register: acm_result
- set_fact:
    certificate_summary_list: "{{ acm_result.stdout }}"
- name: set acm certificate var
  set_fact:
    certificate_arn: "{{ certificate_summary_list.CertificateSummaryList | selectattr('DomainName','equalto', '*.gaiahub.io') | map(attribute='CertificateArn') | list | first }}"
  when: "acm_result.rc == 0"

- debug: msg="There is no issued certificate in aws acm, please check if certificate is expired and should be renewd."
  when: "acm_result.rc != 0"

- name: check if self-signed certificate for ELB already exists
  local_action: command aws iam get-server-certificate --server-certificate-name ELB_Certificate.{{ ec2_region }}
  ignore_errors: yes
  register: cert
  when: "acm_result.rc != 0"

- name: create self-signed certificate for ELB
  local_action: command openssl req -new -nodes -x509 -subj "/C=US/ST=California/L=Palo Alto/O=HP Enterprise/CN=*.{{ ec2_region }}.elb.amazonaws.com" -days 3650 -keyout keys/{{ ec2_region }}/elb.{{ ec2_region }}.key -out keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt -extensions v3_ca creates=keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt
  when: "cert is defined and cert.rc != 0"

- name: upload self-signed certificate for ELB
  local_action: command aws iam upload-server-certificate --server-certificate-name ELB_Certificate.{{ ec2_region }} --certificate-body file://keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt --private-key file://keys/{{ ec2_region }}/elb.{{ ec2_region }}.key
  when: "cert is defined and cert.rc != 0"

- name: set self-signed ssl certificate var if acm certificate not defined
  set_fact:
    certificate_arn: "arn:aws:iam::{{ myuser_out.User.Arn[13:25] }}:server-certificate/ELB_Certificate.{{ ec2_region }}"
  when: certificate_arn is not defined

- name: create security group for ELB
  ec2_group:
    name: "{{ elb_security_group.name }}"
    description: "{{ elb_security_group.desc }}"
    vpc_id: "{{ vpc_id }}"
    region: "{{ ec2_region }}"
    rules: "{{ elb_security_group.rules }}"
  register: elb_sg

- name: Create the security group for the CoreOS cluster
  ec2_group:
    name: "{{ coreos_security_group.name }}"
    description: "{{ coreos_security_group.desc }}"
    vpc_id: "{{ vpc_id }}"
    region: "{{ ec2_region }}"
    rules: "{{ coreos_security_group.rules }}"
  register: coreos_sg

- debug: var=coreos_sg

# Add access to Postgres from coreos_security_group
- name: find rds_sg
  shell: "aws ec2 describe-security-groups --filters Name=group-name,Values='rds_sg_{{ env_nick[environ] }}'"
  register: rds_sg_out
- set_fact:
    rds_sg_out_stdout: "{{ rds_sg_out.stdout | from_json }}"
- debug: var=rds_sg_out_stdout.SecurityGroups[0].GroupId
- name: add rule
  shell: "aws ec2 authorize-security-group-ingress --group-id {{ rds_sg_out_stdout.SecurityGroups[0].GroupId }} --protocol tcp --port 5432 --source-group {{ coreos_sg.group_id }}"

# generate application security keys for further usage by Dex - should be in environment
- name: generate dex admin api key
  shell: "dd if=/dev/random bs=1 count=128 2>/dev/null | base64 | tr -d '\n'"
  register: dex_admin_key_out
- set_fact:
    DEX_API_SECRET: "{{ dex_admin_key_out.stdout }}"
- name: generate dex secret key
  shell: "dd if=/dev/random bs=1 count=32 2>/dev/null | base64 | tr -d '\n'"
  register: dex_secret_key_out
- set_fact:
    DEX_SECRET: "{{ dex_secret_key_out.stdout }}"
- debug: var="{{ DEX_API_SECRET }}"
- debug: var="{{ DEX_SECRET }}"

- name: create ELB
  ec2_elb_lb:
    name: "{{ coreos_elb_name }}"
    state: present
    connection_draining_timeout: 60
    cross_az_load_balancing: "yes"
    region: "{{ ec2_region }}"
    security_group_ids: "{{ elb_sg.group_id }}"
    subnets: "{{ vpc_public_subnets }}"
    listeners:
      - protocol: http
        load_balancer_port: 80
        instance_port: 80
      - protocol: http
        load_balancer_port: 88
        instance_port: 88
      - protocol: https
        load_balancer_port: 443
        instance_protocol: http
        instance_port: 80
        ssl_certificate_id: "{{ certificate_arn }}"
      - protocol: https
        load_balancer_port: 444
        instance_protocol: http
        instance_port: 88
        ssl_certificate_id: "{{ certificate_arn }}"
      - protocol: http
        load_balancer_port: 1936
        instance_port: 1936
      - protocol: http
        load_balancer_port: 8083
        instance_port: 8083
      - protocol: http
        load_balancer_port: 8086
        instance_port: 8086
    health_check:
      ping_protocol: http
      ping_port: 88
      ping_path: "/mgs/"
      response_timeout: 5
      interval: 10
      unhealthy_threshold: 4
      healthy_threshold: 5

- name: get ELB details
  local_action: command aws elb describe-load-balancers --load-balancer-names {{ coreos_elb_name }} --max-items 1 --output json
  register: elb_fact_out

- name: prepare ELB fact
  set_fact:
    elb_fact: "{{ elb_fact_out.stdout }}"

- name: obtain alias hosted zone id
  set_fact:
    id: "{{ hz_ids | get_hosted_zone_id() }}"

- name: create route53 subdomain for environment
  route53:
    command: create
    zone:  gaiahub.io
    record: "{{ dns }}.gaiahub.io"
    type: A
    alias: True
    overwrite: True
    alias_hosted_zone_id: "{{ id }}"
    value: "dualstack.{{ elb_fact.LoadBalancerDescriptions[0].CanonicalHostedZoneName }}"

- name: create route53 4th level domain for webhooks
  route53:
    command: create
    zone:  gaiahub.io
    record: "webhook.{{ dns }}.gaiahub.io"
    type: A
    alias: True
    overwrite: True
    alias_hosted_zone_id: "{{ id }}"
    value: "dualstack.{{ elb_fact.LoadBalancerDescriptions[0].CanonicalHostedZoneName }}"

# Check if DB is available
- name: check Postgres availability
  rds:
    command: facts
    instance_name: "{{ postgres_name }}"
    region: "{{ ec2_region }}"
  register: dbf
  until: dbf.instance.status == "available"
  retries: 15
  delay: 60
