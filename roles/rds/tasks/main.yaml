- debug: var=vpc_id

# Security group for RDS
- name: Create the security group for RDS
  ec2_group:
    name: "{{ rds_security_group.name }}"
    description: "{{ rds_security_group.desc }}"
    vpc_id: "{{ vpc_id }}"
    region: "{{ ec2_region }}"
    rules: "{{ rds_security_group.rules }}"
  register: rds_sg
- name: Print RDS security group details
  debug: var=rds_sg

# Add access to Postgres from coreos_security_group
- name: find rds_sg
  shell: "aws ec2 describe-security-groups --filters Name=group-name,Values='rds_sg_{{ env_nick[environ] }}'"
  register: rds_sg_out
- set_fact:
    rds_sg_out_stdout: "{{ rds_sg_out.stdout | from_json }}"
- debug: var=rds_sg_out_stdout.SecurityGroups[0].GroupId
- name: add rule
  shell: "aws ec2 authorize-security-group-ingress --group-id {{ rds_sg_out_stdout.SecurityGroups[0].GroupId }} --protocol tcp --port 5432 --source-group {{ coreos_sg.group_id }}"


# Subnet for RDS
- name: Find subnet for RDS
  shell: "aws ec2 describe-subnets --filters Name=tag:Name,Values=private-1"
  register: private1_subnet_out
- set_fact:
    private1_subnet: "{{ private1_subnet_out.stdout | from_json }}"
- set_fact:
    zone_rds: "{{ private1_subnet.Subnets[0].AvailabilityZone }}"
#- set_fact:
#    subnet_rds: "{{ private1_subnet.Subnets[0].SubnetId }}"
#- debug: var=zone_rds
#- debug: var=subnet_rds

# Create DB subnet group from all private subnets in the region
# Dataset is based on ec2_vpc_out so that only looks on the relevant VPC
- name: Create RDS subnet group
  rds_subnet_group:
    region: "{{ ec2_region }}"
    state: present
    name: "postgres-{{ environ }}-{{ dns }}-subnet-group"
    description: See the group name
    subnets: "{{ ec2_vpc_out.subnets | get_subnets('tier', 'private') }}"

- name: create Postgres for production environment
  rds:
    command: create
    db_engine: postgres
    size: "{{ volume_size.rds[environ] }}"
    iops: "{{ iops[environ] }}"
    instance_type: "{{ instance_type.rds[environ] }}"
    instance_name: "{{ postgres_name }}"
    username: dex
    password: dex_pass
    db_name: dex_db
    backup_retention: "{{ backup_retention[environ] }}"
    engine_version: "{{ postgres_version }}"
    upgrade: no
    multi_zone: yes
    publicly_accessible: no
    region: "{{ ec2_region }}"
    subnet: "postgres-{{ environ }}-{{ dns }}-subnet-group"
    vpc_security_groups: "{{ rds_sg.group_id }}"
    wait: no
    tags:
      Environment: "{{ environ }}"
  register: rds
  when: environ=="production"

- name: create Postgres for develop environment
  rds:
    command: create
    db_engine: postgres
    size: "{{ volume_size.rds[environ] }}"
    instance_type: "{{ instance_type.rds[environ] }}"
    instance_name: "{{ postgres_name }}"
    username: dex
    password: dex_pass
    db_name: dex_db
    backup_retention: "{{ backup_retention[environ] }}"
    engine_version: "{{ postgres_version }}"
    upgrade: no
    multi_zone: no
    publicly_accessible: no
    region: "{{ ec2_region }}"
    zone: "{{ zone_rds }}"
    subnet: "postgres-{{ environ }}-{{ dns }}-subnet-group"
    vpc_security_groups: "{{ rds_sg.group_id }}"
    wait: no
    tags:
      Environment: "{{ environ }}"
  register: rds
  when: environ=="develop"

# Check if DB creation has started (availability is checked later)
- name: check Postgres existence
  rds:
    command: facts
    instance_name: "{{ postgres_name }}"
    region: "{{ ec2_region }}"
  register: dbf
  ignore_errors: yes
  until: dbf|success
  retries: 30
  delay: 10

# Fetch endpoint; use aws cli because ansible returns the endpoint
# only after the status switched to available - too long to wait
- name: wait until the endpoint is ready (availability is checked later)
  shell: "aws rds describe-db-instances --db-instance-identifier {{ postgres_name }}"
  register: dbfacts
  until: dbfacts.stdout.find("rds.amazonaws.com") != -1
  retries: 90
  delay: 10
- set_fact:
    rds_ep: "{{ dbfacts.stdout | from_json | get_rds_endpoint() }}"
- debug: var=rds_ep

#- name: wait until the endpoint is ready - via ansible
#  rds:
#    command: facts
#    region: "{{ ec2_region }}"
#    instance_name: "{{ postgres_name }}"
#  register: dbfacts
#  until: dbfacts|success and dbfacts.instance.endpoint
#  retries: 90
#  delay: 10
#- set_fact:
#    rds_ep: "{{ dbfacts.instance.endpoint }}"
#- debug: var=rds_ep


- name: create Route53 record set for postgres
  route53:
    command: create
    private_zone: True
    zone: "{{ vpc_dns_zone }}"
    record: "postgres.{{ vpc_dns_zone }}"
    type: CNAME
    value: "{{ rds_ep }}"
    ttl: "{{ rds_posgres_ep_ttl }}"
- set_fact:
    POSTGRES_EP_OUT: "postgres.{{ vpc_dns_zone }}"

# Check if DB is available
- name: check Postgres availability
  rds:
    command: facts
    instance_name: "{{ postgres_name }}"
    region: "{{ ec2_region }}"
  register: dbf
  until: dbf.instance.status == "available"
  retries: 15
  delay: 60
