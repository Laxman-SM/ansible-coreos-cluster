- debug: var=vpc_id

# set facts with file content for cloud-config
- set_fact:
    gaia_ca_crt_file: "keys/{{ ec2_region }}/{{ gaia_ca_file }}.crt"
- stat:
    path: "{{ gaia_ca_crt_file }}"
  register: st_out
- fail:
    msg: "Missing {{ gaia_ca_crt_file }} file. Please copy this file from ansible-bastion or make the keys directory a symlink"
  when: st_out.stat.exists != True
- shell: "base64 -w0 {{ gaia_ca_crt_file }}"
  register: gaia_ca_crt_content_out
- set_fact:
    gaia_ca_crt_content: "{{ gaia_ca_crt_content_out.stdout }}"

- name: create self-signed certificate for ELB
  local_action: command openssl req -new -nodes -x509 -subj "/C=US/ST=California/L=Palo Alto/O=HP Enterprise/CN=*.{{ ec2_region }}.elb.amazonaws.com" -days 3650 -keyout keys/{{ ec2_region }}/elb.{{ ec2_region }}.key -out keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt -extensions v3_ca creates=keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt

- name: upload self-signed certificate for ELB
  local_action: command aws iam upload-server-certificate --server-certificate-name ELB_Certificate.{{ ec2_region }} --certificate-body file://keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt --private-key file://keys/{{ ec2_region }}/elb.{{ ec2_region }}.key
#  iam_cert:
#    name: ELB_Certificate.{{ ec2_region }}
#    state: present
#    cert: ./keys/{{ ec2_region }}/elb.{{ ec2_region }}.crt
#    key: ./keys/{{ ec2_region }}/elb.{{ ec2_region }}.key

- name: create security group for ELB
  ec2_group:
    name: "{{ elb_security_group.name }}"
    description: "{{ elb_security_group.desc }}"
    vpc_id: "{{ vpc_id }}"
    region: "{{ ec2_region }}"
    rules: "{{ elb_security_group.rules }}"
  register: elb_sg

- name: Create the security group for the CoreOS cluster
  ec2_group:
    name: "{{ coreos_security_group.name }}"
    description: "{{ coreos_security_group.desc }}"
    vpc_id: "{{ vpc_id }}"
    region: "{{ ec2_region }}"
    rules: "{{ coreos_security_group.rules }}"
  register: coreos_sg

# generate user-data from template
- name: create template
  template: src='user-data.j2' dest='/tmp/user-data.txt'
- name: load user-data content
  set_fact:
    # user_data: "{{ lookup('file', '/tmp/user-data.txt') | b64encode }}" <-- base64 encoded user-data is not recognized by CoreOS
    user_data: "{{ lookup('file', '/tmp/user-data.txt') }}"

# search for latest CoreOS AMI from alpha/beta/stable channel
- name: search for the latest CoreOS AMI image from "{{ coreos_channel }}"
  ec2_ami_find:
    region: "{{ ec2_region }}"
    name: "CoreOS-{{coreos_channel}}-{{coreos_version}}-hvm"
    virtualization_type: hvm
    sort: name
    sort_order: descending
    sort_end: 1
    no_result_action: fail
  register: find_out
- name: get CoreOS AMI
  set_fact:
    coreos_ami: "{{ find_out.results[0] }}"

- name: create ELB
  ec2_elb_lb:
    name: "{{ coreos_elb_name }}"
    state: present
    connection_draining_timeout: 60
    cross_az_load_balancing: "yes"
    region: "{{ ec2_region }}"
    security_group_ids: "{{ elb_sg.group_id }}"
    subnets: "{{ vpc_public_subnets }}"
    listeners:
      - protocol: http
        load_balancer_port: 80
        instance_port: 80
      - protocol: http
        load_balancer_port: 88
        instance_port: 88
      - protocol: https
        load_balancer_port: 443
        instance_protocol: http
        instance_port: 80
        ssl_certificate_id: "arn:aws:iam::662068354453:server-certificate/ELB_Certificate.{{ ec2_region }}"
      - protocol: https
        load_balancer_port: 444
        instance_protocol: http
        instance_port: 88
        ssl_certificate_id: "arn:aws:iam::662068354453:server-certificate/ELB_Certificate.{{ ec2_region }}"
      - protocol: http
        load_balancer_port: 1936
        instance_port: 1936
    health_check:
      ping_protocol: http
      ping_port: 88
      ping_path: "/mgs/"
      response_timeout: 5
      interval: 10
      unhealthy_threshold: 4
      healthy_threshold: 5

# create CoreOS launch configuration
# note: for flannel use manually create role with required pilicies
#       https://coreos.com/flannel/docs/latest/vpc-backend.html
- name: create CoreOS launch configuration
  shell: "aws autoscaling create-launch-configuration --launch-configuration-name '{{ coreos_lc_name }}' --key-name '{{ coreos_keypair_name }}' --image-id '{{ coreos_ami.ami_id }}' --security-groups '{{ coreos_sg.group_id }}' --instance-type '{{ coreos_instance_type }}' --iam-instance-profile '{{ coreos_instance_profile }}' --user-data 'file:///tmp/user-data.txt' --block-device-mappings '{{ coreos_block_device_mappings | to_json }}'"

# create CoreOS autoscale group
- name: create CoreOS autoscale group
  ec2_asg:
    name: "{{ coreos_asg_name }}"
    load_balancers:
      - "{{ coreos_elb_name }}"
    region: "{{ ec2_region }}"
    launch_config_name: "{{ coreos_lc_name }}"
    health_check_period: "{{ coreos_health_check_period }}"
    desired_capacity: "{{ coreos_cluster_size }}"
    min_size: "{{ coreos_cluster_size }}"
    max_size: "{{ coreos_max_cluster_size }}"
    tags: "{{ coreos_instance_tags }}"
    vpc_zone_identifier: "{{ vpc_private_subnets }}"
    wait_for_instances: yes
  register: asg_out

- name: Turn off "source destination check" - needed for flunnel
  local_action: command aws ec2 modify-instance-attribute --region {{ ec2_region }} --instance-id {{ item }} --no-source-dest-check
  with_items: "{{ asg_out.instances }}"
